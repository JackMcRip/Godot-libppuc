extends Node

# Godot 4.0+ Compatibility
# Diese Zeile hinzufügen, wenn du GDScript 2.0 (Godot 4.0+) verwendest
# class_name YAMLParser

# Top-level properties
var ppucVersion
var rom
var serialPort
var platform
var coinDoorClosedSwitch
var gameOnSolenoid
var debug

# Collections
var boards = []
var dipSwitches = {}
var switches = []
var ledStripes = []
var pwmOutput = []
var mechs = {}

# Function to parse YAML file
func parse_yaml_file(file_path):
	var file = FileAccess.open(file_path, FileAccess.READ)
	if file == null:
		printerr("Fehler beim Öffnen der Datei: " + file_path + ", Fehlercode: " + str(FileAccess.get_open_error()))
		return
	
	var lines = file.get_as_text().split("\n")
	file.close()
	
	# First pass: Parse all sections
	var i = 0
	while i < lines.size():
		var line = lines[i].strip_edges()
		
		if line.is_empty() or line.begins_with("#"):
			i += 1
			continue
		
		if ":" in line:
			var parts = line.split(":", true, 1)
			var key = parts[0].strip_edges()
			var value = parts[1].strip_edges() if parts.size() > 1 else ""
			
			# Parse top-level properties
			match key:
				"ppucVersion":
					ppucVersion = convert_value(value)
				"rom":
					rom = convert_value(value)
				"serialPort":
					serialPort = convert_value(value)
				"platform":
					platform = convert_value(value)
				"coinDoorClosedSwitch":
					coinDoorClosedSwitch = convert_value(value)
				"gameOnSolenoid":
					gameOnSolenoid = convert_value(value)
				"debug":
					debug = convert_value(value)
				"boards":
					i = parse_collection(lines, i + 1, boards)
					continue
				"dipSwitches":
					if value == "{}" or value == "{  }":
						dipSwitches = {}
					else:
						i = parse_dictionary(lines, i + 1, dipSwitches)
						continue
				"switches":
					i = parse_collection(lines, i + 1, switches)
					continue
				"ledStripes":
					i = parse_collection(lines, i + 1, ledStripes)
					continue
				"pwmOutput":
					i = parse_collection(lines, i + 1, pwmOutput)
					continue
				"mechs":
					if value == "{}" or value == "{  }":
						mechs = {}
					else:
						i = parse_dictionary(lines, i + 1, mechs)
						continue
		
		i += 1
	
	print_debug("YAML Datei erfolgreich eingelesen")
	print_debug("Gefundene Boards: " + str(boards.size()))
	print_debug("Gefundene Switches: " + str(switches.size()))
	print_debug("Gefundene LED-Streifen: " + str(ledStripes.size()))
	print_debug("Gefundene PWM-Ausgänge: " + str(pwmOutput.size()))

# Parse a collection of items (boards, switches, ledStripes, pwmOutput)
func parse_collection(lines, start_index, collection):
	var i = start_index
	var current_item = null
	
	while i < lines.size():
		var line = lines[i].strip_edges()
		var indent = count_indent(lines[i])
		
		if line.is_empty() or line.begins_with("#"):
			i += 1
			continue
		
		# End of collection - new top-level key
		if indent == 0 and ":" in line:
			return i
		
		# New item in collection
		if indent == 2 and line == "-":
			current_item = {}
			collection.append(current_item)
			i += 1
			continue
		
		# Item property
		if indent == 4 and ":" in line and current_item != null:
			var parts = line.split(":", true, 1)
			var key = parts[0].strip_edges()
			var value = parts[1].strip_edges() if parts.size() > 1 else ""
			
			# Handle sub-collections (lamps, flashers, gi in ledStripes)
			if key in ["lamps", "flashers", "gi"]:
				if value == "{}" or value == "{  }":
					current_item[key] = {}
				else:
					current_item[key] = []
					i = parse_sub_collection(lines, i + 1, current_item[key])
					continue
			else:
				current_item[key] = convert_value(value)
		
		i += 1
	
	return i

# Parse a sub-collection (lamps, flashers, gi in ledStripes)
func parse_sub_collection(lines, start_index, collection):
	var i = start_index
	var current_item = null
	
	while i < lines.size():
		var line = lines[i].strip_edges()
		var indent = count_indent(lines[i])
		
		if line.is_empty() or line.begins_with("#"):
			i += 1
			continue
		
		# End of sub-collection - new property at parent level or end of parent
		if indent <= 4:
			return i
		
		# New item in sub-collection
		if indent == 6 and line == "-":
			current_item = {}
			collection.append(current_item)
			i += 1
			continue
		
		# Item property
		if indent == 8 and ":" in line and current_item != null:
			var parts = line.split(":", true, 1)
			var key = parts[0].strip_edges()
			var value = parts[1].strip_edges() if parts.size() > 1 else ""
			
			current_item[key] = convert_value(value)
		
		i += 1
	
	return i

# Parse a dictionary (dipSwitches, mechs)
func parse_dictionary(lines, start_index, dictionary):
	var i = start_index
	
	while i < lines.size():
		var line = lines[i].strip_edges()
		var indent = count_indent(lines[i])
		
		if line.is_empty() or line.begins_with("#"):
			i += 1
			continue
		
		# End of dictionary - new top-level key
		if indent == 0 and ":" in line:
			return i
		
		# Dictionary entry
		if indent == 2 and ":" in line:
			var parts = line.split(":", true, 1)
			var key = parts[0].strip_edges()
			var value = parts[1].strip_edges() if parts.size() > 1 else ""
			
			dictionary[key] = convert_value(value)
		
		i += 1
	
	return i

# Convert string value to appropriate type
func convert_value(value_str):
	if value_str == "true" or value_str == "True":
		return true
	elif value_str == "false" or value_str == "False":
		return false
	
	# Try to convert to integer
	var int_value = value_str.to_int()
	if str(int_value) == value_str:
		return int_value
	
	# Try to convert to float
	var float_value = value_str.to_float()
	
	# Use regex to check if the string represents a float
	var float_pattern = RegEx.new()
	float_pattern.compile("^-?\\d+(\\.\\d+)?$")
	if float_pattern.search(value_str):
		return float_value
	
	# Return as string if no conversion possible
	return value_str

# Count spaces at beginning of line
func count_indent(line):
	var count = 0
	for i in range(line.length()):
		if line[i] == " ":
			count += 1
		else:
			break
	return count

# Debug-Funktion zum Ausgeben der eingelesenen Daten
func print_data():
	print("Top-Level Eigenschaften:")
	print("  ppucVersion: ", ppucVersion)
	print("  rom: ", rom)
	print("  serialPort: ", serialPort)
	print("  platform: ", platform)
	print("  coinDoorClosedSwitch: ", coinDoorClosedSwitch)
	print("  gameOnSolenoid: ", gameOnSolenoid)
	print("  debug: ", debug)
	
	print("\nBoards (", boards.size(), "):")
	for board in boards:
		print("  - ", board)
	
	print("\nSwitches (", switches.size(), "):")
	for switch in switches:
		print("  - ", switch)
	
	print("\nLED-Streifen (", ledStripes.size(), "):")
	for stripe in ledStripes:
		print("  - Beschreibung: ", stripe.get("description", ""))
		if stripe.has("lamps") and typeof(stripe["lamps"]) == TYPE_ARRAY:
			print("    Lampen (", stripe["lamps"].size(), "):")
			for lamp in stripe["lamps"]:
				print("      - ", lamp)
	
	print("\nPWM-Ausgänge (", pwmOutput.size(), "):")
	for output in pwmOutput:
		print("  - ", output)

# Called when the node enters the scene tree for the first time
func _ready():
	# Pfad zur YAML-Datei, sollte angepasst werden
	var config_path = ProjectSettings.globalize_path("res://config/elektra.yml")
	parse_yaml_file(config_path)
	
	# Daten ausgeben
	if debug:
		print_data()
